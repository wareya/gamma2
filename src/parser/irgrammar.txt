float: TOKEN
%[0-9]+\.[0-9]+([eE]([+-])?[0-9]+)?f(32|64)%
%[0-9]+\.([eE]([+-])?[0-9]+)?f(32|64)%
%\.[0-9]+([eE]([+-])?[0-9]+)?f(32|64)%

integer: TOKEN
%[0-9]+(i|u)(8|16|32|64)%
%0x[0-9A-Fa-f]+(i|u)(8|16|32|64)%

integer_token: TOKEN
%[0-9]+%
%0x[0-9A-Fa-f]+%

name: TOKEN
%[a-zA-Z_][0-9a-zA-Z_]*%

embedname: EMBED
%[a-zA-Z_][0-9a-zA-Z_]*%

rvarname:
$embedname$

ptr_type: HIDELITERALS
ptr ( $type$ )

funcptr_args:
>>? $type$...,

funcptr_type: HIDELITERALS
funcptr ( $type$ , ( $funcptr_args$ ) )

array_type: HIDELITERALS
array ( $type$ , $integer_token$ )

fundamental_type: TOKEN
u8
i8
u16
i16
u32
i32
u64
i64
f32
f64


type:
$ptr_type$
$funcptr_type$
$array_type$
$fundamental_type$

capsname: TOKEN
%[A-Z][0-9a-zA-Z_]*%

parenexpr: HIDELITERALS
( $expr$ )

lvar:
$lval_rhunexpr$
$name$

supersimplexpr: SIMPLIFY
$parenexpr$
$float$
$integer$
$rvarname$

simplexpr: SIMPLIFY
$rhunexpr$
$parenexpr$
$float$
$integer$
$rvarname$

expr: SIMPLIFY
$binexpr_0$

binexpr_0: SIMPLIFY LEFTBINEXPR 0
$binexpr_1$ >>? $binop_0$ $binexpr_0$

binexpr_1: SIMPLIFY LEFTBINEXPR 1
$binexpr_2$ >>? $binop_1$ $binexpr_1$

binexpr_2: SIMPLIFY LEFTBINEXPR 2
$binexpr_3$ >>? $binop_2$ $binexpr_2$

binexpr_3: SIMPLIFY LEFTBINEXPR 3
$lhunop$ >>? $binop_3$ $binexpr_3$

unary:
$unop$ $lhunop$

lhunop: SIMPLIFY
$unary$
$simplexpr$


unop:
!
-
+
*

binop_0:
and
or
&&
||

binop_1:
==
!=
>=
<=
>
<

binop_2:
+
-

binop_3:
*
/
%

arglist: EMBED
$expr$...,

funcargs: HIDELITERALS
( $arglist$? )

arrayindex: HIDELITERALS
[ $expr$ ]

indirection: HIDELITERALS
. $name$

rhunexpr_right:
$funcargs$
$arrayindex$
$indirection$

rhunexpr:
$supersimplexpr$ $rhunexpr_right$+

lval_rhunexpr:
$supersimplexpr$ $rhunexpr_right$+

statementlist: HIDELITERALS
{ $statement$* }

binstateop:
=

binstate:
$lvar$ $binstateop$ $expr$ ;

funcarg:
$type$ $name$

funcdefargs:
>>? $funcarg$...,

funcdef: HIDELITERALS
$type$ $name$ ( $funcdefargs$ ) $statementlist$

structparts:
$declaration$*

structdef: HIDELITERALS
struct $name$ { $structparts$ }

ifcondition: HIDELITERALS
if $parenexpr$ goto $name$ ;

goto: HIDELITERALS
goto $name$ ;

return: HIDELITERALS
return $expr$ ;
return ;

instruction: HIDELITERALS
$goto$
$return$

label: HIDELITERALS
$name$ :

declaration: HIDELITERALS
$type$ $name$ ;

statement: HIDELITERALS
$statementlist$
$declaration$
$ifcondition$
$binstate$
$instruction$
$label$
$expr$ ;

rootstatement: SIMPLIFY
$structdef$
$funcdef$

program:
$rootstatement$*
